<!DOCTYPE html>
<html>
<head>
  <title>Walking Cubes</title>  
  <script src="js/three.min.js"></script>
  <script type="text/javascript" src="js/dat.gui.min.js"></script>
</head>
<body>
	<script type="application/javascript">

	  	var cubesGUI;

	  	var WalkingCubesGUI = function() {
        this.speed = 0.25;
        this.numWaves = 0.25;
        this.colorFactor = 1;
        this.colorTravel = false;
        this.color1 = [ 137, 209, 184 ]; // RGB array
        this.color2 = [ 204, 226, 189 ]; // RGB array	  
      };    

	    window.onload = function() {
			cubesGUI = new WalkingCubesGUI();
			var gui = new dat.GUI();		
			gui.add(cubesGUI, 'speed', 0, 1);
			gui.add(cubesGUI, 'numWaves', 0, 1);
			gui.add(cubesGUI, 'colorFactor', 0, 1);
			gui.add(cubesGUI, 'colorTravel');
			gui.addColor(cubesGUI, 'color1');
			gui.addColor(cubesGUI, 'color2');

			var scene = new THREE.Scene();
			//var camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				
			//SETUP
			var aspectRatio = window.innerWidth / window.innerHeight;
			var camera = new THREE.OrthographicCamera( 0, 100 * aspectRatio, 0, 100 , 1, 1000 )
			var renderer = new THREE.WebGLRenderer();

			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			

			//CONSTANTS
			var NUM_ROWS = 6;
			var NUM_COLS = 15;
			var SHORT = 5;
			var LONG = 10;
			var EDGE = Math.sqrt(Math.pow(SHORT,2) + Math.pow(LONG,2));
			var ROW_HEIGHT = EDGE + SHORT;
			var COL_WIDTH = LONG *2;
			console.log(EDGE);

			var MAX_SPEED = 4;
			var MAX_NUM_WAVES = 8;

			var count = 0;
			var center = new THREE.Vector3(50,50,0);
			var maxDistance = center.distanceTo(new THREE.Vector3(0,0,0));

			var time = 0;

			//GEOMETRY
			var geometry = new THREE.Geometry();

			var y_begin = 10;
			var row_count = 0;

			for (var centery = y_begin; centery < y_begin+NUM_ROWS*ROW_HEIGHT; centery += ROW_HEIGHT) {      
        		var begin = (row_count % 2) * LONG;

        		//if (centery == 50) continue;        		
        		//debugger;
        		console.log("outer loop");
        		for (var centerx = begin; centerx < NUM_COLS*COL_WIDTH; centerx +=COL_WIDTH) {                     
            		
        			//console.log(centerx);
        			console.log("inner loop");
        			console.log("centery");
        			console.log(centery);

            		var p1 = new THREE.Vector3(centerx,centery - SHORT,0);		            
		            var p5 = new THREE.Vector3(centerx - LONG, centery + EDGE,0);
		            var p7 = new THREE.Vector3(centerx + LONG, centery + EDGE,0);
		            var middlep1p3 = new THREE.Vector3(p1.x, p1.y + SHORT,0);
		            var destinationp7 = new THREE.Vector3(p7.x, p7.y + SHORT,0);
		            var destinationp5 = new THREE.Vector3(p5.x, p5.y + SHORT,0);

		            var d13 = middlep1p3.distanceTo(center);
            		var d7 = destinationp7.distanceTo(center);
            		var d5 = destinationp5.distanceTo(center);

            		var speed = 0.25 * MAX_SPEED;
        		    var numWavesFactor = 0.25 * MAX_NUM_WAVES;
           			 numWavesFactor = numWavesFactor + 1;

           			var verticalScalar13 = ((Math.sin(speed*(time + (d13/maxDistance)*numWavesFactor*Math.PI)) + 1)/2);
           			var verticalScalar5 = (Math.sin(speed*(time + (d5/maxDistance)*numWavesFactor*Math.PI)) + 1)/2;
            		var verticalScalar7 = (Math.sin(speed*(time + (d7/maxDistance)*numWavesFactor*Math.PI)) + 1)/2;  

            		var p2, p3, p4, p6;
		            p1 = new THREE.Vector3(centerx, centery - SHORT * verticalScalar13, 0);
		            p2 = new THREE.Vector3(centerx - LONG, centery, 0);
		            p3 = new THREE.Vector3(centerx, centery + SHORT * verticalScalar13, 0);
		            p4 = new THREE.Vector3(centerx + LONG, centery, 0);
		            p5 = new THREE.Vector3(centerx - LONG, centery + EDGE + SHORT * (1 - verticalScalar5), 0);
		            p6 = new THREE.Vector3(centerx, centery + SHORT + EDGE, 0); 
		            p7 = new THREE.Vector3(centerx + LONG, centery + EDGE + SHORT * (1 - verticalScalar7), 0);

		            var d3 = p3.distanceTo(center);
		            var colorFactor = verticalScalar13;


		            //COLORS
		            var blue = new THREE.Color("rgb(137,209,184)");
		            var yellow = new THREE.Color("rgb(204,226,189)");
		            var white = new THREE.Color("rgb(255,255,255)");
		            var black = new THREE.Color("rgb(0,0,0)");
		            var mainColor = blue.clone().lerp(yellow,colorFactor);
		            //var lighter = white.lerp(mainColor, 0.5);
		            //var darker = black.lerp(mainColor, 0.5);

		            geometry.vertices.push(p1);
                geometry.vertices.push(p2);
                geometry.vertices.push(p3);
                geometry.vertices.push(p4);
                geometry.vertices.push(p5);
                geometry.vertices.push(p6);
                geometry.vertices.push(p7);

                var normal = new THREE.Vector3(1,0,0);

                var indexCount = count * 7;
                geometry.faces.push(new THREE.Face3(indexCount,indexCount + 1, indexCount + 3, normal, white, 0));
                geometry.faces.push(new THREE.Face3(indexCount + 1,indexCount + 2,indexCount + 3, normal, white, 0));
                geometry.faces.push(new THREE.Face3(indexCount + 2,indexCount + 5,indexCount + 3, normal, blue, 0));
                geometry.faces.push(new THREE.Face3(indexCount + 3,indexCount + 5,indexCount + 6, normal, blue, 0));
                geometry.faces.push(new THREE.Face3(indexCount + 1,indexCount + 5,indexCount + 2, normal, yellow, 0));
                geometry.faces.push(new THREE.Face3(indexCount + 1,indexCount + 4,indexCount + 5, normal, yellow, 0));
                
        		    count++;
        		}
        		row_count++;

    		}

			geometry.computeFaceNormals();

			var material = new THREE.MeshBasicMaterial( { 
			    color: 0xf0f0f0, 
			    shading: THREE.FlatShading,
			    vertexColors: THREE.FaceColors 
			});			

			var box_grid = new THREE.Mesh(geometry, material);
			scene.add(box_grid);

      camera.position.x = -30;
			camera.position.z = 1000;
      console.log("length");
			console.log(geometry.faces.length);

			function render() {
				requestAnimationFrame(render);
				renderer.render(scene, camera);
			}
			render();
		};

	</script>  
  
</body>
</html>
