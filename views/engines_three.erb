<!DOCTYPE html>
<html>
<head>
  <title>Walking Cubes</title>  
  <script src="js/three.min.js"></script>
  <script type="text/javascript" src="js/dat.gui.min.js"></script>
</head>
<body>
	<script type="application/javascript">

	  	var cubesGUI;
	  	var geometry;
	  	var scene;
	  	var material;
	  	var renderer;
	  	var camera;

	  	var WalkingCubesGUI = function() {
	        this.speed = 0.25;
	        this.numWaves = 0.25;
	        this.colorFactor = 1;
	        this.colorTravel = false;
	        this.color1 = [ 137, 209, 184 ]; // RGB array
	        this.color2 = [ 204, 226, 189 ]; // RGB array	  
      	};    

	    window.onload = function() {

	    	init();
	    	animate();
		};

		function init() {			
			cubesGUI = new WalkingCubesGUI();
			var gui = new dat.GUI();		
			gui.add(cubesGUI, 'speed', 0, 1);
			gui.add(cubesGUI, 'numWaves', 0, 1);
			gui.add(cubesGUI, 'colorFactor', 0, 1);
			gui.add(cubesGUI, 'colorTravel');
			gui.addColor(cubesGUI, 'color1');
			gui.addColor(cubesGUI, 'color2');

			scene = new THREE.Scene();
			//var camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				
			//SETUP
			var aspectRatio = window.innerWidth / window.innerHeight;
			camera = new THREE.OrthographicCamera( 0, 100 * aspectRatio, 0, 100 , 1, 1000 )
			renderer = new THREE.WebGLRenderer();

			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );						

			material = new THREE.MeshBasicMaterial( { 
			    color: 0xf0f0f0, 
			    shading: THREE.FlatShading,
			    vertexColors: THREE.FaceColors 
			});		

      		camera.position.x = -30;
			camera.position.z = 1000; 

    	};

    	function updateGeometry(time) {

    		//CONSTANTS
			var NUM_ROWS = 6;
			var NUM_COLS = 15;
			var SHORT = 5;
			var LONG = 10;
			var EDGE = Math.sqrt(Math.pow(SHORT,2) + Math.pow(LONG,2));
			var ROW_HEIGHT = EDGE + SHORT;
			var COL_WIDTH = LONG *2;
			console.log(EDGE);

			var MAX_SPEED = 4;
			var MAX_NUM_WAVES = 8;

			var count = 0;
			var center = new THREE.Vector3(50,50,0);
			var maxDistance = center.distanceTo(new THREE.Vector3(0,0,0));

			//GEOMETRY
			geometry = new THREE.Geometry();

			var y_begin = 10;
			var row_count = 0;

			for (var centery = y_begin; centery < y_begin+NUM_ROWS*ROW_HEIGHT; centery += ROW_HEIGHT) {      
        		var begin = (row_count % 2) * LONG;
        		
        		for (var centerx = begin; centerx < NUM_COLS*COL_WIDTH; centerx +=COL_WIDTH) {                     

            		var p1 = new THREE.Vector3(centerx,centery - SHORT,0);		            
		            var p5 = new THREE.Vector3(centerx - LONG, centery + EDGE,0);
		            var p7 = new THREE.Vector3(centerx + LONG, centery + EDGE,0);
		            var middlep1p3 = new THREE.Vector3(p1.x, p1.y + SHORT,0);
		            var destinationp7 = new THREE.Vector3(p7.x, p7.y + SHORT,0);
		            var destinationp5 = new THREE.Vector3(p5.x, p5.y + SHORT,0);

		            var d13 = middlep1p3.distanceTo(center);
            		var d7 = destinationp7.distanceTo(center);
            		var d5 = destinationp5.distanceTo(center);

            		var speed = 0.25 * MAX_SPEED;
        		    var numWavesFactor = 0.25 * MAX_NUM_WAVES;
           			 numWavesFactor = numWavesFactor + 1;

           			var verticalScalar13 = ((Math.sin(speed*(time + (d13/maxDistance)*numWavesFactor*Math.PI)) + 1)/2);
           			var verticalScalar5 = (Math.sin(speed*(time + (d5/maxDistance)*numWavesFactor*Math.PI)) + 1)/2;
            		var verticalScalar7 = (Math.sin(speed*(time + (d7/maxDistance)*numWavesFactor*Math.PI)) + 1)/2;  

            		var p2, p3, p4, p6;
		            p1 = new THREE.Vector3(centerx, centery - SHORT * verticalScalar13, 0);
		            p2 = new THREE.Vector3(centerx - LONG, centery, 0);
		            p3 = new THREE.Vector3(centerx, centery + SHORT * verticalScalar13, 0);
		            p4 = new THREE.Vector3(centerx + LONG, centery, 0);
		            p5 = new THREE.Vector3(centerx - LONG, centery + EDGE + SHORT * (1 - verticalScalar5), 0);
		            p6 = new THREE.Vector3(centerx, centery + SHORT + EDGE, 0); 
		            p7 = new THREE.Vector3(centerx + LONG, centery + EDGE + SHORT * (1 - verticalScalar7), 0);

		            var d3 = p3.distanceTo(center);
		            var colorFactor = verticalScalar13;


		            //COLORS
		            var blue = new THREE.Color("rgb(137,209,184)");
		            var yellow = new THREE.Color("rgb(204,226,189)");
		            var white = new THREE.Color("rgb(255,255,255)");
		            var black = new THREE.Color("rgb(0,0,0)");
		            var mainColor = blue.clone().lerp(yellow,colorFactor);
		            //var lighter = white.lerp(mainColor, 0.5);
		            //var darker = black.lerp(mainColor, 0.5);

		            geometry.vertices.push(p1);
	                geometry.vertices.push(p2);
	                geometry.vertices.push(p3);
	                geometry.vertices.push(p4);
	                geometry.vertices.push(p5);
	                geometry.vertices.push(p6);
	                geometry.vertices.push(p7);

                	var normal = new THREE.Vector3(1,0,0);

	                var indexCount = count * 7;
	                geometry.faces.push(new THREE.Face3(indexCount,indexCount + 1, indexCount + 3, normal, white, 0));
	                geometry.faces.push(new THREE.Face3(indexCount + 1,indexCount + 2,indexCount + 3, normal, white, 0));
	                geometry.faces.push(new THREE.Face3(indexCount + 2,indexCount + 5,indexCount + 3, normal, blue, 0));
	                geometry.faces.push(new THREE.Face3(indexCount + 3,indexCount + 5,indexCount + 6, normal, blue, 0));
	                geometry.faces.push(new THREE.Face3(indexCount + 1,indexCount + 5,indexCount + 2, normal, yellow, 0));
	                geometry.faces.push(new THREE.Face3(indexCount + 1,indexCount + 4,indexCount + 5, normal, yellow, 0));
                
        		    count++;
        		}
        		
        		row_count++;

    		}
    	};

    	function animate() {
    		requestAnimationFrame( animate );
			var time = Date.now();
			updateGeometry(time);
			render();
    	};

    	function render() {
    		geometry.verticesNeedUpdate = true;    			

			var box_grid = new THREE.Mesh(geometry, material);
			scene.add(box_grid);

    		renderer.render(scene, camera);
    	};		    

	</script>  
  
</body>
</html>
